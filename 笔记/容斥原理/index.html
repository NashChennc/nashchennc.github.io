<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>容斥原理 - NaN&#39;s Blog ｜ Not a Nihilist</title>

  <!-- MDUI CSS -->
  <link rel="stylesheet" href="/mdui/css/mdui.min.css">

  <!-- KaTeX CSS (If needed) -->
  <link rel="stylesheet" href="/katex/katex.min.css">

  <!-- Custom CSS (最小化，只包含无法用 MDUI 实现的部分) -->
  <link rel="stylesheet" href="/css/custom.css">

  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <meta name="theme-color" content="#3F51B5">
<meta name="generator" content="Hexo 8.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
<body class="mdui-appbar-with-toolbar mdui-theme-primary-indigo mdui-theme-accent-pink mdui-color-grey-100">
  
  <!-- Header/AppBar -->
  <header class="appbar mdui-appbar mdui-appbar-fixed">
    <div class="mdui-toolbar mdui-color-theme">
        
          <div class="mdui-toolbar-spacer"></div>
            <div class="mdui-tab mdui-tab-full-width">
                
                <a href="/" class="mdui-ripple ">
                    Home
                </a>
                
                
                    
                        <a href="/categories/笔记" class="mdui-ripple ">
                            笔记 | 6
                        </a>
                    
                
                    
                        <a href="/categories/科研" class="mdui-ripple ">
                            科研 | 7
                        </a>
                    
                
                    
                        <a href="/categories/碎碎念" class="mdui-ripple ">
                            碎碎念 | 29
                        </a>
                    
                
                    
                        <a href="/categories/流水账" class="mdui-ripple ">
                            流水账 | 4
                        </a>
                    
                
                    
                        <a href="/categories/工具箱" class="mdui-ripple ">
                            工具箱 | 16
                        </a>
                    
                
                    
                        <a href="/categories/其它" class="mdui-ripple ">
                            其它 | 4
                        </a>
                    
                
            </div>
        
        <div class="mdui-toolbar-spacer"></div>
        <a href="/about" class="mdui-btn mdui-btn-icon mdui-ripple" mdui-tooltip="{content: 'About'}">
            <i class="mdui-icon material-icons"> more_vert </i>
        </a>
    </div>
</header>

  <!-- Main Content (Layout control moved to individual views) -->
  <div id="main-content">
    <!-- 全宽 Banner -->
<div class="banner-container" style="height: 350px;">
    <div class="banner-bg" style="background-image: url(/image/banner.png);"></div>
    
    <div class="mdui-card-media-covered banner-overlay" style="background: rgba(0, 0, 0, 0.4);">
        <div class="mdui-container">
            <div class="mdui-card-primary mdui-float-right mdui-text-color-white mdui-p-y-2">
                <div class="mdui-card-primary-title" style="font-weight: 300;">
                    NaN&#39;s Blog ｜ Not a Nihilist
                </div>
                <div class="mdui-card-primary-subtitle mdui-float-right" style="opacity: 0.9;">
                    Nomen a Nullo. Nihil ad Nomen.
                </div>
            </div>
        </div>
    </div>
</div>
<!-- FAB -->
<div id="exampleFab" class="mdui-fab-wrapper" mdui-fab="{trigger: 'hover'}">
    <a class="mdui-fab mdui-ripple mdui-color-theme-accent" href="/archives" mdui-tooltip="{content: 'goto Archive', position: 'left'}">
        <i class="mdui-icon material-icons">bookmark</i>
        <i class="mdui-icon mdui-fab-opened material-icons">bookmark</i>
    </a>
    <div class="mdui-fab-dial">
        <a href="/about" class="mdui-fab mdui-fab-mini mdui-ripple mdui-color-teal">
            <i class="mdui-icon material-icons">more_vert</i>
        </a>
        <a href="#top" class="mdui-fab mdui-fab-mini mdui-ripple mdui-color-blue-700" mdui-tooltip="{content: 'goto top', position: 'left'}">
            <i class="mdui-icon material-icons">keyboard_arrow_up</i>
        </a>
        <a href="#page-bottom" class="mdui-fab mdui-fab-mini mdui-ripple mdui-color-indigo" mdui-tooltip="{content: 'goto bottom', position: 'left'}">
            <i class="mdui-icon material-icons">keyboard_arrow_down</i>
        </a>
    </div>
</div>

<div class="mdui-container">
    <div class="mdui-row mdui-p-t-1 mdui-p-b-1">
        <!-- 文章内容 -->

        <div class="mdui-col-md-9 mdui-col-xs-12 mdui-p-t-1 mdui-p-b-4">
            <div class="mdui-card mdui-hoverable">
                <div class="mdui-card-primary mdui-p-x-5">
                    <div class="mdui-card-primary-title mdui-typo-display-1">
                        容斥原理
                    </div>
                    <div class="mdui-row mdui-p-t-2">
                        <div class="mdui-col-xs-9 mdui-typo-caption-opacity">
                            Last Update: 2025/12/29 17:20
                        </div>
                        <div class="mdui-col-xs-3">
                            <div class="mdui-float-right mdui-typo">
                                
                                    <a href="/categories/%E7%AC%94%E8%AE%B0/">
                                        笔记
                                    </a>
                                
                            </div>
                        </div>
                    </div>
                    <div class="mdui-divider"></div>
                    <br/>
                </div>
                <div class="mdui-card-content mdui-typo mdui-p-x-5">
                    <h3 id="第一部分：容斥原理的代数证明（特征函数法）">第一部分：容斥原理的代数证明（特征函数法）</h3>
<p>设定：</p>
<p>设 $U$ 为有限全集，$A_1, A_2, \dots, A_n$ 是 $U$ 的子集。</p>
<p>我们定义集合 $S$ 的特征函数 $\mathbb{1}_S: U \to {0, 1}$ 为：</p>
<p>$$\mathbb{1}_S(x) = \begin{cases} 1, &amp; x \in S \ 0, &amp; x \notin S \end{cases}$$</p>
<p><strong>基础性质</strong>：</p>
<ol>
<li>
<p><strong>求和即计数</strong>：$|S| = \sum_{x \in U} \mathbb{1}_S(x)$</p>
</li>
<li>
<p><strong>交集即乘积</strong>：$\mathbb{1}_{A \cap B}(x) = \mathbb{1}_A(x) \mathbb{1}_B(x)$</p>
</li>
<li>
<p><strong>补集即作差</strong>：$\mathbb{1}_{A^c}(x) = 1 - \mathbb{1}_A(x)$</p>
</li>
</ol>
<p>证明目标：</p>
<p>求 $\left| \bigcup_{i=1}^n A_i \right|$。</p>
<p><strong>证明过程</strong>：</p>
<p>首先考虑元素 $x$ 不属于任何一个集合 $A_i$ 的情况，即 $x \in \left( \bigcup_{i=1}^n A_i \right)^c = \bigcap_{i=1}^n A_i^c$。</p>
<p>其特征函数可以写为补集的交集：</p>
<p>$$\mathbb{1}<em>{(\bigcup</em>{i=1}^n A_i)^c}(x) = \prod_{i=1}^n \left( 1 - \mathbb{1}_{A_i}(x) \right)$$</p>
<p>利用乘法分配律展开右侧的乘积。对于下标集合 $I = {1, 2, \dots, n}$ 的任意子集 $T \subseteq I$，该展开式中的每一项对应选择 $-\mathbb{1}_{A_j}$ (当 $j \in T$) 和 $1$ (当 $j \notin T$) 的乘积：</p>
<p>$$\begin{aligned} \prod_{i=1}^n (1 - \mathbb{1}<em>{A_i}(x)) &amp;= \sum</em>{T \subseteq I} \left( \prod_{j \in T} (-\mathbb{1}<em>{A_j}(x)) \right) \ &amp;= \sum</em>{T \subseteq I} (-1)^{|T|} \prod_{j \in T} \mathbb{1}_{A_j}(x) \end{aligned}$$</p>
<p>根据交集的性质 $\prod_{j \in T} \mathbb{1}<em>{A_j}(x) = \mathbb{1}</em>{\bigcap_{j \in T} A_j}(x)$（规定 $\mathbb{1}<em>{\bigcap</em>{j \in \emptyset} A_j}(x) = \mathbb{1}_U(x) = 1$），代入上式：</p>
<p>$$\mathbb{1}<em>{(\bigcup</em>{i=1}^n A_i)^c}(x) = \sum_{T \subseteq I} (-1)^{|T|} \mathbb{1}<em>{\bigcap</em>{j \in T} A_j}(x)$$</p>
<p>我们需要的是并集 $\bigcup_{i=1}^n A_i$ 的特征函数。利用 $\mathbb{1}<em>S = 1 - \mathbb{1}</em>{S^c}$：</p>
<p>$$\begin{aligned} \mathbb{1}<em>{\bigcup</em>{i=1}^n A_i}(x) &amp;= 1 - \sum_{T \subseteq I} (-1)^{|T|} \mathbb{1}<em>{\bigcap</em>{j \in T} A_j}(x) \ &amp;= 1 - \left( 1 + \sum_{\emptyset \neq T \subseteq I} (-1)^{|T|} \mathbb{1}<em>{\bigcap</em>{j \in T} A_j}(x) \right) \ &amp;= \sum_{\emptyset \neq T \subseteq I} -(-1)^{|T|} \mathbb{1}<em>{\bigcap</em>{j \in T} A_j}(x) \ &amp;= \sum_{\emptyset \neq T \subseteq I} (-1)^{|T|-1} \mathbb{1}<em>{\bigcap</em>{j \in T} A_j}(x) \end{aligned}$$</p>
<p>最后，对全集 $U$ 中的所有 $x$ 求和（利用线性和性质1）：</p>
<p>$$\begin{aligned} \left| \bigcup_{i=1}^n A_i \right| &amp;= \sum_{x \in U} \mathbb{1}<em>{\bigcup</em>{i=1}^n A_i}(x) \ &amp;= \sum_{\emptyset \neq T \subseteq I} (-1)^{|T|-1} \left| \bigcap_{j \in T} A_j \right| \end{aligned}$$</p>
<p><strong>Q.E.D.</strong></p>
<p>接下来将上述证明中的 $(1 - z)$ 展开思想，推广到更广义的代数结构上。</p>
<p>在这一部分，我们将之前的“集合包含关系”抽象化，建立一套适用于所有偏序关系的通用代数系统。你会发现，无论是容斥原理、子集卷积还是数论中的莫比乌斯反演，本质上都是同一个矩阵运算在不同结构上的体现。</p>
<hr>
<h1>Phase 1: 理论重构 —— 偏序集上的关联代数</h1>
<h2 id="1-基础定义：从集合到偏序集">1. 基础定义：从集合到偏序集</h2>
<p>首先，我们不再局限于集合 $S$ 和包含符号 $\subseteq$，而是讨论更广泛的<strong>偏序集</strong>。</p>
<p>定义 1.1 (Locally Finite Poset)</p>
<p>设 $P$ 是一个集合，$\preceq$ 是其上的偏序关系（满足自反性、反对称性、传递性）。</p>
<p>如果对于任意 $x, y \in P$，区间 $[x, y] = {z \in P \mid x \preceq z \preceq y}$ 都是有限的，则称 $(P, \preceq)$ 为局部有限偏序集。</p>
<blockquote>
<p><em>注：这就保证了后续我们在区间内求和时，项数是有限的，不需要考虑无穷级数的收敛问题。</em></p>
</blockquote>
<hr>
<h2 id="2-关联代数-Incidence-Algebra-与-广义卷积">2. 关联代数 (Incidence Algebra) 与 广义卷积</h2>
<p>这是统一框架的核心。我们定义一个函数空间，并在上面定义一种“乘法”。</p>
<p>定义 1.2 (Incidence Algebra $\mathcal{I}(P)$)</p>
<p>$\mathcal{I}(P)$ 是定义在 $P \times P$ 上的所有实值函数 $f$ 的集合，满足：</p>
<p>$$\text{若 } x \not\preceq y, \text{ 则 } f(x, y) = 0$$</p>
<p>(直观理解：这些函数只在合法的偏序区间上有值。)</p>
<p>定义 1.3 (Convolution / 卷积)</p>
<p>对于 $f, g \in \mathcal{I}(P)$，定义它们的卷积 $h = f * g$ 为：</p>
<p>$$h(x, y) = \sum_{x \preceq z \preceq y} f(x, z) g(z, y)$$</p>
<blockquote>
<p>⚠️ 核心洞察 (Matrix Interpretation)</p>
<p>这个定义非常抽象，但如果你把偏序集 $P$ 中的元素按照拓扑序排列，把 $f(x, y)$ 看作矩阵 $M_f$ 的第 $(x, y)$ 个元素，你会发现：</p>
<ol>
<li>
<p>由于 $x \not\preceq y \implies f(x, y) = 0$，这些矩阵都是<strong>上三角矩阵</strong>。</p>
</li>
<li>
<p><strong>卷积 $f * g$ 完完全全就是矩阵乘法 $M_f \times M_g$</strong>。</p>
</li>
</ol>
<p>这一视角的转变至关重要：<strong>卷积满足结合律</strong> $(f * g) * h = f * (g * h)$，因为矩阵乘法满足结合律。</p>
</blockquote>
<hr>
<h2 id="3-三大核心算子">3. 三大核心算子</h2>
<p>在这个代数结构中，有三个函数扮演着特殊的角色。</p>
<h3 id="3-1-单位元：Delta-函数-delta">3.1 单位元：Delta 函数 ($\delta$)</h3>
<p>$$\delta(x, y) = \begin{cases} 1 &amp; x = y \ 0 &amp; x \neq y \end{cases}$$</p>
<p>显然，对于任意 $f$，有 $f * \delta = \delta * f = f$。它对应于单位矩阵 $I$。</p>
<h3 id="3-2-求和算子：Zeta-函数-zeta">3.2 求和算子：Zeta 函数 ($\zeta$)</h3>
<p>这是将原函数转化为“前缀和”的关键。</p>
<p>$$\zeta(x, y) = \begin{cases} 1 &amp; x \preceq y \ 0 &amp; \text{otherwise} \end{cases}$$</p>
<p>若我们令 $g = f * \zeta$，展开看：</p>
<p>$$g(x, y) = \sum_{x \preceq z \preceq y} f(x, z) \cdot 1 = \sum_{x \preceq z \preceq y} f(x, z)$$</p>
<p>这正是我们在各类算法中求的SOS (Sum Over Subsets) 或 前缀和。它对应于所有合法位置均为 1 的上三角矩阵。</p>
<h3 id="3-3-差分算子：Mobius-函数-mu">3.3 差分算子：Möbius 函数 ($\mu$)</h3>
<p>如果我们要从 $g$ (前缀和) 还原回 $f$ 怎么办？在矩阵代数中，这意味着我们需要求 $\zeta$ 的逆矩阵。</p>
<p>定义 $\mu = \zeta^{-1}$，即满足：</p>
<p>$$\mu * \zeta = \delta$$</p>
<p>根据卷积定义，我们可以推导出 $\mu$ 的递归计算式：</p>
<p>当 $x = y$ 时：</p>
<p>$$\mu(x, x) \zeta(x, x) = 1 \implies \mu(x, x) = 1$$</p>
<p>当 $x &lt; y$ 时：</p>
<p>$$(\mu * \zeta)(x, y) = \sum_{x \preceq z \preceq y} \mu(x, z) \zeta(z, y) = \sum_{x \preceq z \le y} \mu(x, z) = 0$$</p>
<p>分离出最后一项 ($z=y$)：</p>
<p>$$\mu(x, y) + \sum_{x \preceq z &lt; y} \mu(x, z) = 0$$</p>
<p>$$\implies \mu(x, y) = - \sum_{x \preceq z &lt; y} \mu(x, z)$$</p>
<blockquote>
<p><strong>结论</strong>：这就是 Möbius 函数的本质定义——<strong>Zeta 函数的代数逆元</strong>。所有的 $(-1)^k$ 系数都是从这个简单的递归式里算出来的。</p>
</blockquote>
<hr>
<h2 id="4-Mobius-反演公式-The-Inversion-Formula">4. Möbius 反演公式 (The Inversion Formula)</h2>
<p>基于上述代数结构，容斥原理（Möbius 反演）的证明变得显而易见。</p>
<p>定理：</p>
<p>$$g = f * \zeta \iff f = g * \mu$$</p>
<p>证明：</p>
<p>利用结合律和逆元定义：</p>
<p>$$\begin{aligned} g &amp;= f * \zeta \ g * \mu &amp;= (f * \zeta) * \mu \ g * \mu &amp;= f * (\zeta * \mu) \quad (\text{结合律}) \ g * \mu &amp;= f * \delta \quad (\text{逆元定义}) \ g * \mu &amp;= f \end{aligned}$$</p>
<p><strong>Q.E.D.</strong></p>
<hr>
<h2 id="5-从双变量到单变量-The-Bridge-to-Practice">5. 从双变量到单变量 (The Bridge to Practice)</h2>
<p>在实际应用（如算法竞赛或组合计数）中，我们通常处理的是单变量函数 $f(x)$，而不是 $f(x, y)$。我们将单变量函数视为上述代数结构的一种特例（或者说，模上的作用）。</p>
<p>通常我们固定一端。例如，固定底端为 $\hat{0}$ (最小元)，设 $f(x) \equiv f(\hat{0}, x)$。</p>
<p>那么反演公式变为我们熟悉的形式：</p>
<p>形式 1 (Sum over Subset / Divisors):</p>
<p>$$g(x) = \sum_{y \preceq x} f(y) \iff f(x) = \sum_{y \preceq x} g(y)\mu(y, x)$$</p>
<p>形式 2 (Sum over Superset / Multiples):</p>
<p>(这是通过对偶偏序集 $P^*$ 得到的，相当于固定顶端)</p>
<p>$$g(x) = \sum_{x \preceq y} f(y) \iff f(x) = \sum_{x \preceq y} \mu(x, y)g(y)$$</p>
<hr>
<h2 id="6-总结与图解">6. 总结与图解</h2>
<p>为了巩固这一部分，请想象以下矩阵图像：</p>
<ol>
<li>
<p><strong>$f$ (原函数向量)</strong> 经过 <strong>$\times \zeta$ (求和矩阵)</strong> 变成了 <strong>$g$ (前缀和向量)</strong>。</p>
</li>
<li>
<p>矩阵 $\zeta$ 全是 0 和 1，非常稠密，直接乘是 $O(N^2)$。</p>
</li>
<li>
<p>但 $\zeta$ 往往具有特殊的<strong>克罗内克积 (Kronecker Product)</strong> 结构（如在子集卷积中），这允许我们用 $O(N \log N)$ 的分治算法（FZT/FWHT）来加速这个矩阵乘法。</p>
</li>
<li>
<p><strong>容斥原理</strong>仅仅是把 <strong>$\times \zeta$</strong> 变成了 <strong>$\times \zeta^{-1}$</strong> (即 $\times \mu$)。</p>
</li>
</ol>
<p>我们将把 $P$ 替换为具体的 $2^S$ (布尔格) 和 $\mathbb{Z}^+$ (整除格)，看看抽象的 $\mu(x, y)$ 是如何具体变成 $(-1)^{|B|-|A|}$ 和数论中的 $\mu(n)$ 的。这会解释为什么不同领域的容斥公式长得不一样。</p>
<p>好的，我们进入 <strong>Phase 2: 经典模型的统一</strong>。</p>
<p>在这一阶段，我们将 Phase 1 中那个抽象的“关联代数”模具，分别盖在“集合”和“整数”这两个具体的泥坯上。你会惊讶地发现，<strong>子集反演</strong>和<strong>数论反演</strong>竟然是完全同构的——它们本质上都是“多维网格”上的同一个操作。</p>
<hr>
<h1>Phase 2: 经典模型的统一 —— 三大卷积的映射</h1>
<h2 id="1-核心工具：积偏序集-Product-Poset">1. 核心工具：积偏序集 (Product Poset)</h2>
<p>在深入具体模型前，我们需要一个强大的引理来连接它们。</p>
<p>引理：Möbius 函数的积性</p>
<p>如果偏序集 $P$ 可以分解为两个偏序集的直积 $P = P_1 \times P_2$，即 $(x_1, x_2) \preceq (y_1, y_2) \iff x_1 \preceq_1 y_1 \land x_2 \preceq_2 y_2$。</p>
<p>那么 $P$ 上的 Möbius 函数满足：</p>
<p>$$\mu_P((x_1, x_2), (y_1, y_2)) = \mu_{P_1}(x_1, y_1) \cdot \mu_{P_2}(x_2, y_2)$$</p>
<blockquote>
<p><em>通俗理解：如果一个复杂结构是由简单的积木搭出来的，那么它的容斥系数就是各积木容斥系数的乘积。</em></p>
</blockquote>
<hr>
<h2 id="2-模型-A：布尔格-The-Boolean-Lattice-——-集合的世界">2. 模型 A：布尔格 (The Boolean Lattice) —— 集合的世界</h2>
<h3 id="2-1-结构分析">2.1 结构分析</h3>
<ul>
<li>
<p><strong>对象</strong>：集合 $S = {1, 2, \dots, n}$ 的幂集 $2^S$。</p>
</li>
<li>
<p><strong>关系</strong>：包含关系 $\subseteq$。</p>
</li>
<li>
<p>结构分解：</p>
<p>对于任意子集 $A \subseteq S$，我们可以用特征向量 $(b_1, b_2, \dots, b_n)$ 表示，其中 $b_i \in {0, 1}$。</p>
<p>$A \subseteq B$ 等价于对每一位 $i$，都有 $b_i(A) \le b_i(B)$。</p>
<p>这意味着：布尔格同构于 $n$ 个“长度为1的链”的直积。</p>
<p>$$2^S \cong \underbrace{C_2 \times C_2 \times \dots \times C_2}_{n \text{ times}}$$</p>
<p>其中 $C_2$ 是简单的链 $0 \to 1$。</p>
</li>
</ul>
<h3 id="2-2-Mobius-函数推导">2.2 Möbius 函数推导</h3>
<p>我们只需要看最基础的链 $C_2 = {0, 1}$：</p>
<ol>
<li>
<p>$\mu(0, 0) = 1$</p>
</li>
<li>
<p>$\mu(0, 1) = -1$ (由 $\mu(0,0)+\mu(0,1)=0$ 得出)</p>
</li>
</ol>
<p>根据积性引理，对于 $A \subseteq B$，设 $D = B \setminus A$ (即那些从 0 变到 1 的位)：</p>
<p>$$\mu(A, B) = \prod_{i=1}^n \mu(b_i(A), b_i(B))$$</p>
<ul>
<li>
<p>若 $i \in B \setminus A$（0变1），贡献 $-1$。</p>
</li>
<li>
<p>若 $i \in A$ 或 $i \notin B$（0变0 或 1变1），贡献 $1$。</p>
</li>
</ul>
<p>结论：</p>
<p>$$\mu(A, B) = (-1)^{|B \setminus A|} = (-1)^{|B| - |A|}$$</p>
<p>这就解释了集合容斥中那个 $(-1)^k$ 的由来。</p>
<h3 id="2-3-对应卷积：子集卷积与-OR-卷积">2.3 对应卷积：子集卷积与 OR-卷积</h3>
<p>在此偏序集上：</p>
<ul>
<li>
<p>Zeta 变换 ($f * \zeta$)：</p>
<p>$$g(S) = \sum_{T \subseteq S} f(T)$$</p>
<p>算法：Fast Zeta Transform (FZT)，亦称 SOS DP。</p>
<p>本质：在 $n$ 个维度上依次做前缀和。</p>
</li>
<li>
<p>Möbius 逆变换 ($g * \mu$)：</p>
<p>$$f(S) = \sum_{T \subseteq S} (-1)^{|S|-|T|} g(T)$$</p>
<p>算法：Inverse FZT。</p>
<p>本质：在 $n$ 个维度上依次做差分。</p>
</li>
</ul>
<hr>
<h2 id="3-模型-B：整除格-The-Divisibility-Lattice-——-数论的世界">3. 模型 B：整除格 (The Divisibility Lattice) —— 数论的世界</h2>
<h3 id="3-1-结构分析">3.1 结构分析</h3>
<ul>
<li>
<p><strong>对象</strong>：正整数集 $\mathbb{Z}^+$。</p>
</li>
<li>
<p><strong>关系</strong>：整除关系 $d \mid n$。</p>
</li>
<li>
<p>结构分解 (算术基本定理)：</p>
<p>任意整数 $n = p_1^{a_1} p_2^{a_2} \dots p_k^{a_k}$。</p>
<p>$d \mid n$ 等价于对每个质因子 $p_i$，指数满足 $0 \le e_i(d) \le e_i(n)$。</p>
<p>这意味着：整除格同构于无穷多个“无限链”的直积。</p>
<p>$$\mathbb{Z}^+ \cong C_{\infty} \times C_{\infty} \times \dots$$</p>
<p>每个 $C_{\infty}$ 对应一个质数 $p$ 的指数链 $1 \to p \to p^2 \to \dots$。</p>
</li>
</ul>
<h3 id="3-2-Mobius-函数推导">3.2 Möbius 函数推导</h3>
<p>我们要看单条链 $1 \to p \to p^2 \to \dots$ 上的 $\mu$：</p>
<ol>
<li>
<p>$\mu(1, 1) = 1$</p>
</li>
<li>
<p>$\mu(1, p) = -1$ (因为 $\mu(1,1) + \mu(1,p) = 0$)</p>
</li>
<li>
<p>$\mu(1, p^2) = 0$</p>
<ul>
<li><em>Check</em>: $\sum_{d|p^2} \mu(1, d) = \mu(1,1) + \mu(1,p) + \mu(1,p^2) = 1 + (-1) + \mu(1,p^2) = 0 \implies \mu(1,p^2)=0$。</li>
</ul>
</li>
<li>
<p>同理，$\mu(1, p^k) = 0$ 对所有 $k \ge 2$。</p>
</li>
</ol>
<p>根据积性引理，对于 $d \mid n$，令 $k = n/d$：</p>
<p>$$\mu(d, n) = \mu(1, n/d)$$</p>
<p>我们只需看 $n/d$ 的质因子分解。</p>
<ul>
<li>
<p>如果 $n/d$ 包含任何平方因子（即某条链上跨度 $\ge 2$），则结果为 0。</p>
</li>
<li>
<p>否则，结果为 $(-1)^{\text{质因子个数}}$。</p>
</li>
</ul>
<p>结论：</p>
<p>这完美推导出了数论中的经典 Möbius 函数定义：</p>
<p>$$\mu(n) = \begin{cases} 1 &amp; n=1 \ (-1)^k &amp; n = p_1 \dots p_k \text{ (无平方因子)} \ 0 &amp; \text{有平方因子} \end{cases}$$</p>
<h3 id="3-3-对应卷积：狄利克雷卷积-Dirichlet-Convolution">3.3 对应卷积：狄利克雷卷积 (Dirichlet Convolution)</h3>
<p>在此偏序集上：</p>
<ul>
<li>
<p>广义卷积 ($f * g$)：</p>
<p>$$h(n) = \sum_{d|n} f(d)g(n/d)$$</p>
<p>这就是大名鼎鼎的狄利克雷卷积。</p>
</li>
<li>
<p>Möbius 反演：</p>
<p>$$g(n) = \sum_{d|n} f(d) \iff f(n) = \sum_{d|n} \mu(n/d)g(d)$$</p>
</li>
</ul>
<hr>
<h2 id="4-统一视角总结表-Unification-Table">4. 统一视角总结表 (Unification Table)</h2>
<p>这是本节的精华，建议背诵或截图。</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>布尔格 (Sets)</strong></th>
<th><strong>整除格 (Numbers)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>元素</strong></td>
<td>集合 $S$</td>
<td>整数 $n$</td>
</tr>
<tr>
<td><strong>基本单元</strong></td>
<td>元素 $x \in S$</td>
<td>质因子 $p$</td>
</tr>
<tr>
<td><strong>偏序关系</strong></td>
<td>$\subseteq$ (包含)</td>
<td>$\mid$ (整除)</td>
</tr>
<tr>
<td><strong>坐标化</strong></td>
<td>0/1 特征向量 $(b_1, \dots, b_n)$</td>
<td>质指数向量 $(a_1, a_2, \dots)$</td>
</tr>
<tr>
<td><strong>单维结构</strong></td>
<td>短链 $0 \to 1$</td>
<td>长链 $0 \to 1 \to 2 \dots$ (指数)</td>
</tr>
<tr>
<td><strong>Möbius $\mu$</strong></td>
<td>$(-1)^{</td>
<td>B</td>
</tr>
<tr>
<td><strong>卷积名称</strong></td>
<td>子集卷积 / OR-卷积</td>
<td>狄利克雷卷积</td>
</tr>
<tr>
<td><strong>快速算法</strong></td>
<td>Fast Zeta Transform ($O(n2^n)$)</td>
<td>埃氏筛 / 欧拉筛 / 杜教筛</td>
</tr>
</tbody>
</table>
<p>Phase 2 完成了对经典的统一。</p>
<p>但你可能会问：“如果我想做 $A \cup B = S$ 但要求 $|A| + |B| = |S|$ (即不相交) 怎么办？”</p>
<p>或者 “我想求 $LCM(i, j)$ 的卷积怎么办？”</p>
<p>好的，我们进入 <strong>Phase 3: 进阶变换 —— 处理复杂的组合限制</strong>。</p>
<p>在前两个阶段，我们解决了标准的“包含”和“整除”问题。但在实际的高级算法题或科研中，我们常遇到更棘手的限制，比如“<strong>集合必须不相交</strong>”或者“<strong>求集合中的第 K 大值</strong>”。</p>
<p>这时候，光有基础的 Möbius 反演是不够的，我们需要对代数结构进行“魔改”。</p>
<hr>
<h1>Phase 3: 进阶变换 —— 处理复杂的组合限制</h1>
<h2 id="1-子集卷积-Subset-Convolution">1. 子集卷积 (Subset Convolution)</h2>
<h3 id="1-1-问题引入">1.1 问题引入</h3>
<p>我们在 Phase 2 中学到了布尔格上的卷积（OR-Convolution）：</p>
<p>$$h(S) = \sum_{A \cup B = S} f(A)g(B)$$</p>
<p>这对应的是并集操作。但在很多计数问题（如斯坦纳树、覆盖问题）中，我们要求 $A$ 和 $B$ 不相交，即：</p>
<p>$$h(S) = \sum_{A \cup B = S, A \cap B = \emptyset} f(A)g(B)$$</p>
<p>或者等价地写成：</p>
<p>$$h(S) = \sum_{A \subseteq S} f(A)g(S \setminus A)$$</p>
<p><strong>困境</strong>：如果我们直接用 FZT（SOS DP），会包含 $A \cap B \neq \emptyset$ 的项。Möbius 反演只能处理“包含关系”，无法直接检测“交集是否为空”。</p>
<h3 id="1-2-解决方案：秩变换-Ranked-Mobius-Transform">1.2 解决方案：秩变换 (Ranked Möbius Transform)</h3>
<p>我们需要引入一个新的维度来控制“元素个数”。</p>
<p>观察：$A \cup B = S$ 且 $A \cap B = \emptyset \iff A \cup B = S$ 且 $|A| + |B| = |S|$。</p>
<p>我们可以将状态扩展，手动记录集合的大小（秩, Rank）：</p>
<ol>
<li>
<p><strong>扩域</strong>：定义 $\hat{f}(S, k)$。</p>
<ul>
<li>
<p>若 $|S| = k$，则 $\hat{f}(S, k) = f(S)$。</p>
</li>
<li>
<p>若 $|S| \neq k$，则 $\hat{f}(S, k) = 0$。</p>
</li>
<li>
<p><em>直观理解</em>：将每个 $f(S)$ 看作一个形式多项式 $f(S) z^{|S|}$。</p>
</li>
</ul>
</li>
<li>
<p>变换 (Transform)：</p>
<p>对每一个秩 $k \in [0, n]$，分别进行 FZT。</p>
<p>$$\text{FZT}(\hat{f})(S, k) = \sum_{T \subseteq S} \hat{f}(T, k)$$</p>
</li>
<li>
<p>点积 (Point-wise Product)：</p>
<p>现在的点积不再是简单的乘法，而是多项式乘法（卷积）。</p>
<p>对于固定的 $S$，我们需要计算：</p>
<p>$$\hat{h}(S, k) = \sum_{i=0}^k \text{FZT}(\hat{f})(S, i) \cdot \text{FZT}(\hat{g})(S, k-i)$$</p>
<p>这就是子集卷积复杂度 $O(n^2 2^n)$ 中 $n^2$ 的由来。</p>
</li>
<li>
<p>逆变换 (Inverse Transform)：</p>
<p>对每一个秩 $k$，分别进行 IFZT。最后取 $h(S) = \hat{h}(S, |S|)$。</p>
</li>
</ol>
<p><strong>一句话总结</strong>：子集卷积 = <strong>FZT</strong> (在集合维) + <strong>多项式乘法</strong> (在基数维)。</p>
<hr>
<h2 id="2-Min-Max-容斥">2. Min-Max 容斥</h2>
<p>这是容斥原理在概率论和最优化问题中的一个漂亮推论。它不是通过卷积形式出现的，而是作为一种特殊的线性组合。</p>
<h3 id="2-1-公式">2.1 公式</h3>
<p>设 $S$ 是一个集合，其中每个元素都有一个数值（或随机变量）。</p>
<p>$$\max(S) = \sum_{\emptyset \neq T \subseteq S} (-1)^{|T|-1} \min(T)$$</p>
<p>同理，将 $\min$ 和 $\max$ 对调公式也成立。</p>
<h3 id="2-2-证明（构造系数法）">2.2 证明（构造系数法）</h3>
<p>这其实是构造一个系数函数 $C(T)$，使得：</p>
<p>$$\sum_{\emptyset \neq T \subseteq S} C(T) \min(T) = \max(S)$$</p>
<p>假设 $S$ 中的元素按大小排序为 $x_1 &lt; x_2 &lt; \dots &lt; x_n$（所以 $\max(S) = x_n$）。</p>
<p>考虑第 $k$ 大的元素 $x_k$ 被 $\min(T)$ 选中的次数。</p>
<ul>
<li>
<p>$x_k$ 能成为 $\min(T)$，当且仅当 $T \subseteq {x_k, x_{k+1}, \dots, x_n}$ 且 $x_k \in T$。</p>
</li>
<li>
<p>换句话说，我们要在 ${x_{k+1}, \dots, x_n}$ 选一个子集 $T’$，令 $T = {x_k} \cup T’$。</p>
</li>
<li>
<p>$x_k$ 的总贡献系数为：</p>
<p>$$\sum_{T’ \subseteq {x_{k+1}, \dots, x_n}} (-1)^{(|T’|+1)-1} = \sum_{j=0}^{n-k} \binom{n-k}{j} (-1)^j$$</p>
</li>
<li>
<p>根据二项式定理，这个和式在 $n-k &gt; 0$ 时为 0，仅在 $n-k=0$（即 $x_k$ 是最大值 $x_n$）时为 1。</p>
</li>
<li>
<p><strong>证毕</strong>。</p>
</li>
</ul>
<h3 id="2-3-推广：Kth-Min-Max">2.3 推广：Kth Min-Max</h3>
<p>如果我们想求第 $k$ 大的值：</p>
<p>$$k\text{th-max}(S) = \sum_{\emptyset \neq T \subseteq S} (-1)^{|T|-k} \binom{|T|-1}{k-1} \min(T)$$</p>
<p>这在计算“收集全套卡片的期望时间”（Coupon Collector Problem 变体）时是神器。</p>
<hr>
<h2 id="3-GCD-与-LCM-卷积">3. GCD 与 LCM 卷积</h2>
<p>这是数论格上的“Min/Max”操作。</p>
<ul>
<li>
<p><strong>LCM 卷积</strong>：$h(n) = \sum_{\text{lcm}(i, j) = n} f(i)g(j)$</p>
<ul>
<li>
<p>在整除格中，$\text{lcm}(i, j)$ 是 $i$ 和 $j$ 的<strong>上确界 (Join)</strong>，对应布尔格的<strong>并集</strong>。</p>
</li>
<li>
<p><strong>算法</strong>：就像 OR-卷积使用 SOS DP 一样，LCM 卷积使用 <strong>狄利克雷前缀和</strong>。</p>
<ol>
<li>
<p>$\hat{f}(n) = \sum_{d|n} f(d)$ (Dirichlet Sum)</p>
</li>
<li>
<p>$\hat{h}(n) = \hat{f}(n) \cdot \hat{g}(n)$</p>
</li>
<li>
<p>$h(n) = \sum_{d|n} \mu(n/d) \hat{h}(d)$ (Möbius Inversion)</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>GCD 卷积</strong>：$h(n) = \sum_{\text{gcd}(i, j) = n} f(i)g(j)$</p>
<ul>
<li>
<p>$\text{gcd}(i, j)$ 是 <strong>下确界 (Meet)</strong>，对应布尔格的<strong>交集</strong>。</p>
</li>
<li>
<p><strong>算法</strong>：使用 <strong>狄利克雷后缀和 (Dirichlet Suffix Sum)</strong>。</p>
<ol>
<li>
<p>$\hat{f}(n) = \sum_{n|k} f(k)$ (Sum over multiples)</p>
</li>
<li>
<p>$\hat{h}(n) = \hat{f}(n) \cdot \hat{g}(n)$</p>
</li>
<li>
<p>$h(n) = \sum_{n|k} \mu(k/n) \hat{h}(k)$</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-总结：变换的本质">4. 总结：变换的本质</h2>
<p>我们在这里看到了一个统一的模式：</p>
<p>$$\text{Complex Convolution} \xrightarrow{\mathcal{T}} \text{Pointwise Product} \xrightarrow{\mathcal{T}^{-1}} \text{Result}$$</p>
<table>
<thead>
<tr>
<th><strong>卷积类型</strong></th>
<th><strong>目标操作</strong></th>
<th><strong>变换空间 T</strong></th>
<th><strong>点积操作</strong></th>
<th><strong>核心思想</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>OR</strong></td>
<td>$A \cup B$</td>
<td>子集前缀和</td>
<td>$a \times b$</td>
<td>容斥原理</td>
</tr>
<tr>
<td><strong>AND</strong></td>
<td>$A \cap B$</td>
<td>超集前缀和</td>
<td>$a \times b$</td>
<td>容斥原理</td>
</tr>
<tr>
<td><strong>Subset</strong></td>
<td>$A \sqcup B$</td>
<td>秩 + 子集前缀和</td>
<td><strong>多项式乘法</strong></td>
<td>增加维度区分大小</td>
</tr>
<tr>
<td><strong>LCM</strong></td>
<td>$\text{lcm}(a,b)$</td>
<td>约数前缀和</td>
<td>$a \times b$</td>
<td>整除格上的 OR</td>
</tr>
<tr>
<td><strong>GCD</strong></td>
<td>$\text{gcd}(a,b)$</td>
<td>倍数前缀和</td>
<td>$a \times b$</td>
<td>整除格上的 AND</td>
</tr>
<tr>
<td><strong>XOR</strong></td>
<td>$a \oplus b$</td>
<td>FWHT (Walsh)</td>
<td>$a \times b$</td>
<td>群代数 (非偏序集)</td>
</tr>
</tbody>
</table>
<p>在这一步，我们将把这些数学符号转化为具体的 $O(N \log N)$ 或 $O(n 2^n)$ 代码逻辑，并解释为什么“枚举子集”的 $3^n$ 可以被优化掉。</p>
<p>在前三个阶段，我们完成了从抽象定义到数学公式的推导。现在，我们要将这些 $\sum$ 符号转化为计算机能够高效执行的代码，并揭示为什么这些算法能比暴力枚举快得多的根本原因。</p>
<hr>
<h1>Phase 4: 算法实现与复杂度 (Algorithm Implementation &amp; Complexity)</h1>
<h2 id="1-核心思想：维度分离-Separation-of-Variables">1. 核心思想：维度分离 (Separation of Variables)</h2>
<p>所有“快速变换”算法（FFT, FZT, FWHT, 高维前缀和）的核心思想都是一致的：</p>
<p>将高维空间上的全局操作，分解为每一个维度上的局部操作。</p>
<p>根据 Phase 2 的结论，布尔格 $2^S$ 是 $n$ 个 $C_2$ 链的直积。因此，我们不需要一次性枚举所有子集，而是可以<strong>依次处理每一个二进制位</strong>。</p>
<hr>
<h2 id="2-布尔格上的实现：FZT-SOS-DP">2. 布尔格上的实现：FZT / SOS DP</h2>
<p>这是计算 $g(S) = \sum_{T \subseteq S} f(T)$ 的标准算法。</p>
<h3 id="2-1-代码实现-C-风格">2.1 代码实现 (C++ 风格)</h3>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// A: 存储函数的数组，长度为 2^n</span><br><span class="line">// n: 集合大小 (元素的个数，即维数)</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;           // 枚举每一个维度 (bit)</span><br><span class="line">    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;</span><br><span class="line">        if (mask &amp; (1 &lt;&lt; i)) &#123;          // 如果当前位置为 1</span><br><span class="line">            // 利用容斥原理/前缀和思想：</span><br><span class="line">            // dp[mask] += dp[mask ^ (1&lt;&lt;i)]</span><br><span class="line">            // 这一步把 &quot;第 i 位为 0&quot; 的状态累加到了 &quot;第 i 位为 1&quot; 的状态上</span><br><span class="line">            A[mask] += A[mask ^ (1 &lt;&lt; i)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-复杂度分析">2.2 复杂度分析</h3>
<ul>
<li>
<p><strong>暴力枚举子集</strong>：对于每个 $S$，枚举 $T \subseteq S$。复杂度为 $\sum \binom{n}{k} 2^k = 3^n \approx 1.77 \times 10^9$ (当 $n=20$)。</p>
</li>
<li>
<p><strong>FZT (Yates’s Algorithm)</strong>：</p>
<ul>
<li>
<p>外层循环：枚举 $n$ 个维度。</p>
</li>
<li>
<p>内层循环：遍历 $2^n$ 个状态。</p>
</li>
<li>
<p><strong>复杂度</strong>：$O(n 2^n)$。当 $n=20$ 时约为 $2 \times 10^7$，速度提升巨大。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-逆变换-Inverse-FZT">2.3 逆变换 (Inverse FZT)</h3>
<p>即 Möbius 反演。根据 $\mu$ 的性质，只需将 <code>+=</code> 改为 <code>-=</code> 即可。</p>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 还原 f(S)</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;</span><br><span class="line">        if (mask &amp; (1 &lt;&lt; i)) &#123;</span><br><span class="line">            A[mask] -= A[mask ^ (1 &lt;&lt; i)]; // 差分</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-子集卷积-Subset-Convolution-的实现">3. 子集卷积 (Subset Convolution) 的实现</h2>
<p>对应 Phase 3 中的 Ranked Möbius Transform。我们需要维护“集合大小”这一额外信息。</p>
<h3 id="3-1-算法流程">3.1 算法流程</h3>
<ol>
<li>
<p><strong>分层 (Initialization)</strong>：建立二维数组 <code>hat_f[n+1][1&lt;&lt;n]</code>。将原始数据按 popcount (二进制中1的个数) 填入对应层。</p>
</li>
<li>
<p><strong>变换 (FZT)</strong>：对每一层 <code>k</code> 分别做一次 FZT。</p>
</li>
<li>
<p>卷积 (Pointwise Convolution)：</p>
<p>对于每个 mask，我们要计算一个多项式乘法（长度为 $n+1$）。</p>
<p>C++</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int mask = 0; mask &lt; (1 &lt;&lt; n); ++mask) &#123;</span><br><span class="line">    for (int i = 0; i &lt;= n; ++i) &#123;          // 结果的秩</span><br><span class="line">        for (int j = 0; j &lt;= i; ++j) &#123;      // 枚举分裂点</span><br><span class="line">            // hat_h[i][mask] += hat_f[j][mask] * hat_g[i-j][mask]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>逆变换 (IFZT)</strong>：对每一层 <code>k</code> 分别做一次 Inverse FZT。</p>
</li>
<li>
<p><strong>提取结果</strong>：最终答案为 <code>hat_h[popcount(mask)][mask]</code>。</p>
</li>
</ol>
<h3 id="3-2-复杂度分析">3.2 复杂度分析</h3>
<ul>
<li>
<p><strong>变换部分</strong>：做了 $n+1$ 次 FZT。复杂度 $(n+1) \times O(n 2^n) = O(n^2 2^n)$。</p>
</li>
<li>
<p><strong>点积部分</strong>：对于 $2^n$ 个位置，每个位置做长度为 $n$ 的卷积，代价 $O(n^2)$。总计 $O(n^2 2^n)$。</p>
</li>
<li>
<p><strong>总复杂度</strong>：$O(n^2 2^n)$。</p>
<ul>
<li><em>注</em>：这比暴力 $3^n$ 依然要快，但比普通 OR-卷积慢一个 $n$。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-整除格上的实现：狄利克雷前缀和">4. 整除格上的实现：狄利克雷前缀和</h2>
<p>这是计算 $g(n) = \sum_{d|n} f(d)$ 的高效算法。它和 FZT 是完全同构的，只是“二进制位”变成了“质因子”。</p>
<h3 id="4-1-代码实现-高维前缀和">4.1 代码实现 (高维前缀和)</h3>
<p>C++</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// primes: 预处理出的质数列表</span><br><span class="line">// A: 存储函数值，长度为 N</span><br><span class="line"></span><br><span class="line">for (int p : primes) &#123;              // 枚举每一个“维度” (质因子)</span><br><span class="line">    for (int i = 1; i * p &lt;= N; ++i) &#123; </span><br><span class="line">        // 从小到大枚举，把 &quot;i&quot; 的贡献加到 &quot;i*p&quot; 上</span><br><span class="line">        // 相当于把 &quot;指数为 k&quot; 的贡献加到 &quot;指数为 k+1&quot; 上</span><br><span class="line">        A[i * p] += A[i]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>注意</em>：这里不需要显式处理指数 $p^k$，因为 <code>A[i*p] += A[i]</code> 这一行代码会像滚雪球一样，把 $p^1$ 传给 $p^2$，再传给 $p^3$。</li>
</ul>
<h3 id="4-2-复杂度分析">4.2 复杂度分析</h3>
<ul>
<li>
<p><strong>暴力试除</strong>：对于每个数枚举约数，总复杂度 $O(N \sqrt{N})$ 或 $O(N \log N)$ (调和级数)。</p>
</li>
<li>
<p>狄利克雷前缀和：</p>
<p>复杂度为 $\sum_{p \le N} \frac{N}{p} = N \sum_{p \le N} \frac{1}{p}$。</p>
<p>根据 Mertens 第二定理，$\sum_{p \le N} \frac{1}{p} \approx \log \log N$。</p>
<p>总复杂度：$O(N \log \log N)$。</p>
<ul>
<li>这是一个极度接近线性的复杂度。当 $N=10^7$ 时，$\log \log N \approx 2.6$，几乎就是线性的。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="5-算法对比与速查-Cheat-Sheet">5. 算法对比与速查 (Cheat Sheet)</h2>
<table>
<thead>
<tr>
<th><strong>算法名称</strong></th>
<th><strong>作用</strong></th>
<th><strong>代码特征</strong></th>
<th><strong>复杂度</strong></th>
<th><strong>对应数学操作</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>SOS DP (FZT)</strong></td>
<td>子集求和</td>
<td><code>for i in 0..n: mask &amp; (1&lt;&lt;i)</code></td>
<td>$O(n 2^n)$</td>
<td>$f * \zeta$ (Set)</td>
</tr>
<tr>
<td><strong>Inverse FZT</strong></td>
<td>容斥还原</td>
<td><code>mask -= mask^(1&lt;&lt;i)</code></td>
<td>$O(n 2^n)$</td>
<td>$g * \mu$ (Set)</td>
</tr>
<tr>
<td><strong>Subset Conv</strong></td>
<td>子集卷积</td>
<td>FZT + Rank Loops</td>
<td>$O(n^2 2^n)$</td>
<td>Ranked Transform</td>
</tr>
<tr>
<td><strong>Dirichlet Sum</strong></td>
<td>约数求和</td>
<td><code>for p in primes: A[i*p] += A[i]</code></td>
<td>$O(N \log \log N)$</td>
<td>$f * \zeta$ (Number)</td>
</tr>
<tr>
<td><strong>Möbius Sieve</strong></td>
<td>预处理 $\mu$</td>
<td>线性筛 (Linear Sieve)</td>
<td>$O(N)$</td>
<td>计算 $\mu(n)$</td>
</tr>
</tbody>
</table>
<p>至此，我们的《从容斥原理到广义卷积的统一框架》**笔记已经整理完毕。</p>
<p>这套笔记建立了如下的完整闭环：</p>
<ol>
<li>
<p><strong>特征函数法</strong> $\to$ 证明了经典容斥。</p>
</li>
<li>
<p><strong>关联代数</strong> $\to$ 将容斥抽象为矩阵求逆 ($\mu = \zeta^{-1}$)。</p>
</li>
<li>
<p><strong>积偏序集</strong> $\to$ 解释了为何不同领域的 $\mu$ 形式不同（$(-1)^k$ 的来源）。</p>
</li>
<li>
<p><strong>快速变换</strong> $\to$ 将代数运算转化为 $O(n 2^n)$ 或 $O(N \log \log N)$ 的代码。</p>
</li>
</ol>

                </div>
                

                
                <div class="mdui-divider"></div>
                <div class="mdui-card-actions mdui-p-x-3 mdui-p-y-2">
                    <div class="mdui-row">
                        <div class="mdui-col-sm-3 mdui-text-left">
                            
                        </div>
                        <div class="mdui-col-sm-6"></div>
                        <div class="mdui-col-sm-3 mdui-text-right">
                            
                                <a href="/%E7%AC%94%E8%AE%B0/Polya%20%E8%AE%A1%E6%95%B0%E7%90%86%E8%AE%BA/" class="mdui-ripple mdui-hoverable mdui-p-a-1 mdui-text-truncate" style="display: block; text-decoration: none;">
                                    <div class="mdui-typo-caption mdui-text-color-theme-accent mdui-text-truncate">
                                        Next
                                        <i class="mdui-icon material-icons" style="font-size: 14px; vertical-align: middle;">arrow_forward</i>
                                    </div>
                                    <div class="mdui-typo-body-1 mdui-m-t-1 mdui-text-truncate mdui-text-color-black" style="font-weight: 500;">
                                        笔记 | Polya 计数理论
                                    </div>
                                </a>
                            
                        </div>
                    </div>
                </div>
                
                
            </div>
            
        </div>
        <!-- 侧边栏 -->
        <div class="mdui-col-md-3 mdui-col-xs-12  mdui-p-t-1 mdui-p-b-4 sticky-sidebar" id="post-sidebar">
            
                <div class="mdui-card mdui-shadow-1 toc-full-height">
                    <div class="mdui-card-content toc-card-content">
                        <div class="mdui-typo-heading mdui-m-b-2">Table of Contents</div>
                        <div class="toc-content">
                            <ol class="mdui-list mdui-typo"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E7%9A%84%E4%BB%A3%E6%95%B0%E8%AF%81%E6%98%8E%EF%BC%88%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0%E6%B3%95%EF%BC%89"><span class="mdui-list mdui-typo-text">第一部分：容斥原理的代数证明（特征函数法）</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-1"><a class="mdui-list mdui-typo-link"><span class="mdui-list mdui-typo-text">Phase 1: 理论重构 —— 偏序集上的关联代数</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#1-%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89%EF%BC%9A%E4%BB%8E%E9%9B%86%E5%90%88%E5%88%B0%E5%81%8F%E5%BA%8F%E9%9B%86"><span class="mdui-list mdui-typo-text">1. 基础定义：从集合到偏序集</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#2-%E5%85%B3%E8%81%94%E4%BB%A3%E6%95%B0-Incidence-Algebra-%E4%B8%8E-%E5%B9%BF%E4%B9%89%E5%8D%B7%E7%A7%AF"><span class="mdui-list mdui-typo-text">2. 关联代数 (Incidence Algebra) 与 广义卷积</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#3-%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E7%AE%97%E5%AD%90"><span class="mdui-list mdui-typo-text">3. 三大核心算子</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-1-%E5%8D%95%E4%BD%8D%E5%85%83%EF%BC%9ADelta-%E5%87%BD%E6%95%B0-delta"><span class="mdui-list mdui-typo-text">3.1 单位元：Delta 函数 ($\delta$)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-2-%E6%B1%82%E5%92%8C%E7%AE%97%E5%AD%90%EF%BC%9AZeta-%E5%87%BD%E6%95%B0-zeta"><span class="mdui-list mdui-typo-text">3.2 求和算子：Zeta 函数 ($\zeta$)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-3-%E5%B7%AE%E5%88%86%E7%AE%97%E5%AD%90%EF%BC%9AMobius-%E5%87%BD%E6%95%B0-mu"><span class="mdui-list mdui-typo-text">3.3 差分算子：Möbius 函数 ($\mu$)</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#4-Mobius-%E5%8F%8D%E6%BC%94%E5%85%AC%E5%BC%8F-The-Inversion-Formula"><span class="mdui-list mdui-typo-text">4. Möbius 反演公式 (The Inversion Formula)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#5-%E4%BB%8E%E5%8F%8C%E5%8F%98%E9%87%8F%E5%88%B0%E5%8D%95%E5%8F%98%E9%87%8F-The-Bridge-to-Practice"><span class="mdui-list mdui-typo-text">5. 从双变量到单变量 (The Bridge to Practice)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#6-%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9B%BE%E8%A7%A3"><span class="mdui-list mdui-typo-text">6. 总结与图解</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-1"><a class="mdui-list mdui-typo-link"><span class="mdui-list mdui-typo-text">Phase 2: 经典模型的统一 —— 三大卷积的映射</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#1-%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%EF%BC%9A%E7%A7%AF%E5%81%8F%E5%BA%8F%E9%9B%86-Product-Poset"><span class="mdui-list mdui-typo-text">1. 核心工具：积偏序集 (Product Poset)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#2-%E6%A8%A1%E5%9E%8B-A%EF%BC%9A%E5%B8%83%E5%B0%94%E6%A0%BC-The-Boolean-Lattice-%E2%80%94%E2%80%94-%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%96%E7%95%8C"><span class="mdui-list mdui-typo-text">2. 模型 A：布尔格 (The Boolean Lattice) —— 集合的世界</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-1-%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="mdui-list mdui-typo-text">2.1 结构分析</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-2-Mobius-%E5%87%BD%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="mdui-list mdui-typo-text">2.2 Möbius 函数推导</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-3-%E5%AF%B9%E5%BA%94%E5%8D%B7%E7%A7%AF%EF%BC%9A%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF%E4%B8%8E-OR-%E5%8D%B7%E7%A7%AF"><span class="mdui-list mdui-typo-text">2.3 对应卷积：子集卷积与 OR-卷积</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#3-%E6%A8%A1%E5%9E%8B-B%EF%BC%9A%E6%95%B4%E9%99%A4%E6%A0%BC-The-Divisibility-Lattice-%E2%80%94%E2%80%94-%E6%95%B0%E8%AE%BA%E7%9A%84%E4%B8%96%E7%95%8C"><span class="mdui-list mdui-typo-text">3. 模型 B：整除格 (The Divisibility Lattice) —— 数论的世界</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-1-%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="mdui-list mdui-typo-text">3.1 结构分析</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-2-Mobius-%E5%87%BD%E6%95%B0%E6%8E%A8%E5%AF%BC"><span class="mdui-list mdui-typo-text">3.2 Möbius 函数推导</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-3-%E5%AF%B9%E5%BA%94%E5%8D%B7%E7%A7%AF%EF%BC%9A%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF-Dirichlet-Convolution"><span class="mdui-list mdui-typo-text">3.3 对应卷积：狄利克雷卷积 (Dirichlet Convolution)</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#4-%E7%BB%9F%E4%B8%80%E8%A7%86%E8%A7%92%E6%80%BB%E7%BB%93%E8%A1%A8-Unification-Table"><span class="mdui-list mdui-typo-text">4. 统一视角总结表 (Unification Table)</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-1"><a class="mdui-list mdui-typo-link"><span class="mdui-list mdui-typo-text">Phase 3: 进阶变换 —— 处理复杂的组合限制</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#1-%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF-Subset-Convolution"><span class="mdui-list mdui-typo-text">1. 子集卷积 (Subset Convolution)</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#1-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="mdui-list mdui-typo-text">1.1 问题引入</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#1-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E7%A7%A9%E5%8F%98%E6%8D%A2-Ranked-Mobius-Transform"><span class="mdui-list mdui-typo-text">1.2 解决方案：秩变换 (Ranked Möbius Transform)</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#2-Min-Max-%E5%AE%B9%E6%96%A5"><span class="mdui-list mdui-typo-text">2. Min-Max 容斥</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-1-%E5%85%AC%E5%BC%8F"><span class="mdui-list mdui-typo-text">2.1 公式</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-2-%E8%AF%81%E6%98%8E%EF%BC%88%E6%9E%84%E9%80%A0%E7%B3%BB%E6%95%B0%E6%B3%95%EF%BC%89"><span class="mdui-list mdui-typo-text">2.2 证明（构造系数法）</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-3-%E6%8E%A8%E5%B9%BF%EF%BC%9AKth-Min-Max"><span class="mdui-list mdui-typo-text">2.3 推广：Kth Min-Max</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#3-GCD-%E4%B8%8E-LCM-%E5%8D%B7%E7%A7%AF"><span class="mdui-list mdui-typo-text">3. GCD 与 LCM 卷积</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#4-%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8F%98%E6%8D%A2%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="mdui-list mdui-typo-text">4. 总结：变换的本质</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-1"><a class="mdui-list mdui-typo-link"><span class="mdui-list mdui-typo-text">Phase 4: 算法实现与复杂度 (Algorithm Implementation &amp; Complexity)</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#1-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A%E7%BB%B4%E5%BA%A6%E5%88%86%E7%A6%BB-Separation-of-Variables"><span class="mdui-list mdui-typo-text">1. 核心思想：维度分离 (Separation of Variables)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#2-%E5%B8%83%E5%B0%94%E6%A0%BC%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9AFZT-SOS-DP"><span class="mdui-list mdui-typo-text">2. 布尔格上的实现：FZT &#x2F; SOS DP</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-C-%E9%A3%8E%E6%A0%BC"><span class="mdui-list mdui-typo-text">2.1 代码实现 (C++ 风格)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="mdui-list mdui-typo-text">2.2 复杂度分析</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#2-3-%E9%80%86%E5%8F%98%E6%8D%A2-Inverse-FZT"><span class="mdui-list mdui-typo-text">2.3 逆变换 (Inverse FZT)</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#3-%E5%AD%90%E9%9B%86%E5%8D%B7%E7%A7%AF-Subset-Convolution-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="mdui-list mdui-typo-text">3. 子集卷积 (Subset Convolution) 的实现</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-1-%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="mdui-list mdui-typo-text">3.1 算法流程</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#3-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="mdui-list mdui-typo-text">3.2 复杂度分析</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#4-%E6%95%B4%E9%99%A4%E6%A0%BC%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%89%8D%E7%BC%80%E5%92%8C"><span class="mdui-list mdui-typo-text">4. 整除格上的实现：狄利克雷前缀和</span></a><ol class="mdui-list mdui-typo-child"><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#4-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-%E9%AB%98%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="mdui-list mdui-typo-text">4.1 代码实现 (高维前缀和)</span></a></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-3"><a class="mdui-list mdui-typo-link" href="#4-2-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="mdui-list mdui-typo-text">4.2 复杂度分析</span></a></li></ol></li><li class="mdui-list mdui-typo-item mdui-list mdui-typo-level-2"><a class="mdui-list mdui-typo-link" href="#5-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E4%B8%8E%E9%80%9F%E6%9F%A5-Cheat-Sheet"><span class="mdui-list mdui-typo-text">5. 算法对比与速查 (Cheat Sheet)</span></a></li></ol></li></ol>
                        </div>
                    </div>
                </div>
            
            <div class="mdui-m-t-2">
                <div class="mdui-card mdui-shadow-1">
  <div class="mdui-card-media" style="height: 120px; overflow: hidden;">
    <img src="/image/card.png" class="mdui-img-fluid" style="width: 100%; height: 100%; object-fit: cover;">
  </div>

  <div class="mdui-card-content mdui-text-center" style="position: relative;">
    
      <img src="/image/avatar.jpeg" class="mdui-img-circle mdui-shadow-4 sidebar-avatar-offset" style="width: 80px; height: 80px; border: 2px solid white; display: block; margin-left: auto; margin-right: auto;">
    

    <div class="mdui-typo-headline mdui-m-t-2">NaN / Not a Name</div>
    <div class="mdui-typo-caption mdui-text-color-grey-600 mdui-m-t-1">
      Nomen a Nullo. Nihil ad Nomen.
    </div>
  </div>

  <!-- <div class="mdui-divider"></div>

  <div class="mdui-row mdui-text-center mdui-p-y-2">
    <div class="mdui-col-xs-4">
      <div class="mdui-typo-subheading">68</div>
      <div class="mdui-typo-caption mdui-text-color-grey-600">posts</div>
    </div>
    <div class="mdui-col-xs-4">
      <div class="mdui-typo-subheading">6</div>
      <div class="mdui-typo-caption mdui-text-color-grey-600">Categories</div>
    </div>
    <div class="mdui-col-xs-4">
      <div class="mdui-typo-subheading">0</div>
      <div class="mdui-typo-caption mdui-text-color-grey-600">Tags</div>
    </div>
  </div>

  <div class="mdui-divider"></div> -->

  <div class="mdui-card-actions mdui-text-center">
    
        
            <a href="mailto:your@email.com" target="_blank" class="mdui-btn mdui-btn-icon mdui-ripple mdui-text-color-blue" mdui-tooltip="{content: 'Email'}">
                <i class="mdui-icon material-icons">email</i>
            </a>
        
            <a href="https://github.com/yourusername" target="_blank" class="mdui-btn mdui-btn-icon mdui-ripple mdui-text-color-black" mdui-tooltip="{content: 'Github'}">
                <i class="mdui-icon material-icons">code</i>
            </a>
        
    
  </div>
</div>
            </div>
        </div>
    </div>
</div>
<div id="page-bottom" aria-hidden="true"></div>
  </div>
  <!-- Footer -->
  <footer class="mdui-color-grey-200 mdui-text-center mdui-typo-caption">
  <div class="mdui-container">
    <div class="mdui-p-y-2">
      &copy; 2026 <span class="mdui-text-color-theme">NaN / Not a Name</span>
      <br>
      Powered by <a target="_blank" rel="noopener" href="https://hexo.io/" class="mdui-text-color-theme-accent">Hexo</a> | <a target="_blank" rel="noopener" href="https://www.mdui.org/" class="mdui-text-color-theme-accent">MDUI v1</a>
    </div>
  </div>
</footer>

  <!-- Scripts -->
  <script src="/mdui/js/mdui.min.js"></script>
  <script src="/katex/katex.min.js"></script>
  <script src="/katex/contrib/auto-render.min.js"></script>
  
  <script>
    // 合并所有 DOMContentLoaded 监听器
    document.addEventListener("DOMContentLoaded", function() {
      // KaTeX 数学公式渲染
      renderMathInElement(document.body, {
        // 自定义分隔符，支持 $...$ 和 $$...$$
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ],
        // 忽略的标签
        ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      });

      // 自动为所有表格和图片添加 MDUI 样式类
        var tables = document.getElementsByTagName("table");
        for (var i = 0; i < tables.length; i++) {
            if (!tables[i].classList.contains("mdui-table")) {
                tables[i].classList.add("mdui-table", "mdui-shadow-0");
            }
        }
        var imgs = document.getElementsByTagName("img");
        for (var i = 0; i < imgs.length; i++) {
            if (!imgs[i].classList.contains("mdui-img-fluid")) {
                imgs[i].classList.add("mdui-img-fluid");
            }
        }
    });
  </script>
</body>
</html>